"""
This detector extract information based on 3 file markdown, html which are generated by pandoc and markdown created by mammoth
"""
import subprocess
import mammoth
import re
import os
import os.path as osp
from bs4 import BeautifulSoup
from difflib import SequenceMatcher
def similar(a, b): return SequenceMatcher(None, a, b).ratio() #calculate similar of two string

regex_dict = {
    0 : (r'^\*{2}.+', 'heading'),
    1 : (r'^\d+\.?\s+.+', 'question'),
    2 : (r'^[a-z][a-z]?[\)\.]\s+.+', 'subquestion'),
    3 : (r'^\([0-9A-Za-b]+\)\s+.+|^[A-Z0-9]\.?\s+.+', 'choice'),
    4 : (r'\(data:image\/png;base64,(.+)\)', 'image'),
    6 : (r'___+', 'blank'),
    7 : (r"^[a-zA-Z\$].+", 'auxillary_text') 
}


CATEGORY_MAP = {
    "heading": 0, 
    "question": 1,  
    "subquestion": 2,
    "choice"  : 3,
    "image"   : 4,
    "table"   : 5,
    "blank"   : 6,
    "auxillary_text"   : 7
}
CATEGORY_LEVEL = {
    "heading": 5, 
    "question": 4,  
    "subquestion": 3,
    "choice"  : 1,
    "image"   : 1,
    "table"   : 1,
    "blank"   : 1,
    "auxillary_text"   : 1
}
REVERSE_MAP = {CATEGORY_MAP[k]:k for k in CATEGORY_MAP}

def match_patter(idx, line, pattern, category=None, remove=None, minlen=0):
    """
    The function matches a pattern in a given line of text and returns an object containing the index,
    matched text, and category (if provided) while also removing any specified characters.
    
    :param idx: an integer representing the index of the line being processed
    :param line: The string of text that we want to search for a pattern in
    :param pattern: The regular expression pattern to search for in the given line
    :param category: The category parameter is an optional argument that can be used to specify the
    category of the matched pattern. 
    :param remove: A regular expression pattern to remove from the matched text. It is used to clean up
    the text before returning it as a result
    :return: an object that contains the index of the line, the matched text, and a category (if
    provided). If no matches are found, it returns None.
    """
    matches = re.findall(pattern, line)
    obj = None
    if len(matches) > 0 and len(matches[0]) - matches[0].count(" ")> minlen:
        text = matches[0]
        if (text.count("_") + text.count(".")) / (len(text)-text.count(" ")) > 0.75: cgy = "blank"
        else: cgy = category
        
        if not remove is None:
            text  = re.sub(remove, ' ', text)
        obj = [idx, text, cgy]
    return obj

def classify_text( index, line):
    """
    The function `classify_textt` uses regular expressions to match patterns in a given line of text and
    categorize it as a heading, question, subquestion, choices, or auxiliary/blank.
    
    :param line: The input string that needs to be classified
    :param index: The index parameter is the current line number being processed in the text
    :return: The function `classify_text` returns the object `obj` which is the result of matching a
    regular expression pattern to the input `line` at the given `index`. The regular expression patterns
    are defined in the `regex_dict` dictionary and correspond to different categories such as headings,
    questions, subquestions, choices, and auxillary/blank text. If no pattern matches, `obj` will
    """
    #find heading
    obj = match_patter(index, line, regex_dict[0][0], category=regex_dict[0][1], remove="\*")
    if obj is None:
    #find question
        obj = match_patter(index, line, regex_dict[1][0], category=regex_dict[1][1], minlen=6)
        if obj is None:
            #find subquestion
            obj = match_patter(index, line, regex_dict[2][0], category=regex_dict[2][1], minlen=6)
            if obj is None:
                #find choices
                obj = match_patter(index, line, regex_dict[3][0], category=regex_dict[3][1])
                if obj is None:
                    #auxillary/blank
                    obj = match_patter(index, line, regex_dict[7][0], category=regex_dict[7][1], remove="!\[.+\]\s*")
    return obj

def merge_text(data:list):
    auxitext = []
    pre = -2
    for item in data: #itel = [index, text, category]
        if item[-1] in ["heading", "blank", "auxillary_text"] \
                and item[0] == pre + 1                        \
                and auxitext[-1][-1] in [item[-1], "heading"]  :
            auxitext[-1][1] += f" {item[1]}"   
        else:
            auxitext += [item]
        pre = item[0]
    return auxitext

def group_element(elements):
    """
    The function "group_element" combines elements in a list based on their rank and updates their
    information in a dictionary.
    
    :param elements: The input parameter is a list containing dictionary objects that contain
    information about questions. Each dictionary object must contain a key "child" which is a list of
    indices of other dictionary objects in the same list that are children of the current object. The
    function aims to group the elements based on their rank and combine. Item in element is list with format [index, text, category]
    :return: The function `group_element` returns a tuple containing two lists: `new_arr_2` and
    `new_arr_2_e`.
    """

    def __combine_min_elements(orders, elements):
        '''
        order (list) --> rank of elements
        elements (list) --> containing dictionary objects  contain information of question, must be containt key["child"] = []
        '''
        arr = orders
        idx_e = [i for i in range(len(elements))]
        order = min(orders)
        #Group min elements in orders list : [2 0 0 3 0 1 0 0 1 0 3 2 0 1 0  ] -> [2, [0, 0], 3 [0], 1 [0, 0] 1 [0] 3 2 [0] 1 [0] ]
        tmp, tmp_e, new_arr, new_arr_e =[], [], [], []
        i = len(arr)-1
        while i >= 0:
            if arr[i] > order:
                new_arr = [arr[i], tmp] + new_arr if len(tmp) > 0 else [arr[i]] + new_arr
                new_arr_e = [idx_e[i], tmp_e[::-1]] + new_arr_e if len(tmp_e) > 0 else [idx_e[i]] + new_arr_e
                tmp, tmp_e = [], []
            else:
                tmp += [arr[i]]
                tmp_e += [idx_e[i]]
            i -= 1
        #reduce array for [2, [0, 0], 3 [0], 1 [0, 0] 1 [0] 3 2 [0] 1 [0] ] -> [2, 3, 1, 1, 3, 2, 1]
        new_arr_2, new_arr_2_e = [], []
        i = 0
        while i < len(new_arr):
            if type(new_arr[i]) == int:
                new_arr_2 += [new_arr[i]]
                new_arr_2_e += [new_arr_e[i]]
            else:
                for j in new_arr_e[i]:
                    if elements[j]["name"] in ("image", "table"):
                        if "stimulus" in elements[new_arr_e[i-1]].keys():
                            elements[new_arr_e[i-1]]["stimulus"] += [elements[j]['text']]
                        else: elements[new_arr_e[i-1]]["stimulus"] = [elements[j]['text']]
                    
                    elif elements[j]["name"] in ("auxillary_text", "blank") and len(elements[j]["text"]) > 6:
                        elements[new_arr_e[i-1]]["text"] += f"\n{elements[j]['text']}" if elements[j]["name"] == "blank" else f" {elements[j]['text']}"

                    elif elements[j]["name"] in ("choice"):
                        if "choices" in elements[new_arr_e[i-1]].keys():
                            elements[new_arr_e[i-1]]["choices"] += [elements[j]['text']]
                        else: elements[new_arr_e[i-1]]["choices"] = [elements[j]['text']]
                        elements[new_arr_e[i-1]]["category"] = "MCQ"

                    elif elements[j]["name"] in ("subquestion", "question"):
                        if "subquestions" in elements[new_arr_e[i-1]].keys():
                            elements[new_arr_e[i-1]]["subquestions"] += [ elements[j] ]
                        else: elements[new_arr_e[i-1]]["subquestions"] = [ elements[j] ]
                        elements[new_arr_e[i-1]]["category"] = "MSQ"
                    else: pass 
            i += 1

        new_arr_2_e = [elements[i] for i in new_arr_2_e]
        return new_arr_2, new_arr_2_e

    #######################
    ## exclude unessesary headings --> example: 3322110310322302121023 --> 3221101022302121102
    new_elements=[]
    orders   =[]
    for i, item in enumerate(elements): #item = [idx, text, category]
        item = {'name':item[-1], 'text':item[-2], 'category': "OEQ"}
        if item["name"] == "heading" and i > 0:
            if new_elements[-1]["name"] == "heading":
                new_elements[-1]["text"] += f" {item['text']}"
                continue
            elif i== len(elements)-1:continue
            elif elements[i+1][-1] in ["subquestion"]: continue

        if item["name"] == "auxillary_text" and i > 0 and elements[i-1][-1] in ["choice", "blank"]: 
            if i < len(elements) - 1 and elements[i+1][-1] in ["choice", "blank", "subquestion"]:
                    item["name"]="question" #after choice/blank/subquestion ---> question
            else: item["name"]="heading" #after question/heading ---> heading
    
        orders += [CATEGORY_LEVEL[item["name"]]]
        new_elements += [item]
        
    ## Grouping items
    if len(orders) == 0 : return []
    if orders[0] < max(CATEGORY_LEVEL.values()):
        orders = [max(CATEGORY_LEVEL.values())] + orders
        new_elements = [{"name":'heading', 
                    "text": "Section - 1",
                    "category": "MSQ"}] + new_elements
    o, e = orders, new_elements
    while len(set(o)) > 1:
        o, e = __combine_min_elements(o,e)
    return e

class DocExtraction:
    def __init__(self, root):
        self.root = root

    def infer(self, path):
        filename = path.split("/")[-1]
        file1 = f"{path}.md"
        file2 = f"{path}.html"
        subprocess.run(["pandoc", path, '-o', file1])        
        subprocess.run(["pandoc", path, '-o', file2])  

        objs = []
        #detect text
        with open(file1, "r") as f1: data = [line.strip().replace("\\", "") for line in f1.readlines() if line.strip()]
        for i, line in enumerate(data):
            text = classify_text(i, line)
            if text is None: continue
            objs += [text]
        objs = merge_text(objs) #concatenate adjacent heading/auxillary/blank

        #detect image & table
        with open(path, "rb") as docx_file: result = mammoth.convert_to_markdown(docx_file)
        mamomthfile = [line.strip().replace("\\", "") for line in result.value if line.strip()]
        images = [(mamomthfile[i-1], text) for i, text in enumerate(mamomthfile) if text.find("data:image/png;base64") > 0]

        with  open(file2, "r") as html: S = BeautifulSoup(html, "lxml")
        body = [i for i in S.body if i.text.strip()]
        tables = []
        pre_element = None
        for idx, element in enumerate(body):
            if element.name == "table":
                tables += [("" if pre_element is None else pre_element.text.strip() , element.prettify())]
            pre_element = element

        i = j = 0
        for idx, x in enumerate(data):
            if i < len(tables) and similar(x.lower(), tables[i][0][:len(x)].lower()) > 0.85: #text from markdown usually shoter than html
                obj = [idx, tables[i][1], "table"]
                objs += [obj]
                i += 1
            if j < len(images) and similar(x.lower(), images[i][0].lower()) > 0.85: #text from markdown usually shoter than html
                obj = [idx, images[i][1], "images"]
                objs += [obj]
                j += 1
            if i == len(tables) and j == len(images): break
        
        # Grouping
        objs = sorted(objs, key=lambda x : x[0])
        results = group_element(objs)

        #remove
        # os.remove(path);os.remove(file1);os.remove(file2)

        return results